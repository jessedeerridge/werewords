<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>テンプレ</title>
<style>
/* ★ ページ自体をスクロールさせない（浮かない） */
html, body{
  height:100%;
  overflow:hidden;
}
body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
  background:#fff;
  color:#111;
}

/* ヘッダー固定（ここは好みで） */
header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:10px 12px;
  border-bottom:1px solid #eee;
  position:sticky;
  top:0;
  z-index:400;
  background:#fff;
}
h1{margin:0;font-size:18px;}
.small{font-size:12px;opacity:.75;}

/* ★ mainを「画面内スクロール領域」にする（ページ全体は固定） */
main{
  position:relative;
  height:calc(100vh - 60px);
  overflow:auto;
  -webkit-overflow-scrolling:touch;
}

.join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px;}
.join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
.btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
.btn.primary{background:#111;color:#fff;border-color:#111;}
.btn.ghost{ background:#111;color:#fff;border-color:#111; }
.hidden{display:none;}
#lobby{padding:20px;border-top:1px solid #eee;}
.copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

/* 席ポップ */
.seat-pop{
  position:fixed;
  left:50%;
  bottom:10px;
  transform:translateX(-50%);
  background:#5C3B54;
  border:1px solid #eee;
  border-radius:12px;
  box-shadow:0 12px 28px rgba(0,0,0,.12);
  padding:10px;
  z-index:220;
  display:flex;
  flex-direction:column;
  gap:10px;
  min-width:280px;
}
.seat-pop.hidden{display:none;}
.seat-pop .row{display:flex;gap:8px;align-items:center;}
.seat-pop label{width:84px;font-size:13px;}
.seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
.tab{
  padding:6px 10px;
  border:1px solid #ddd;
  border-radius:999px;
  cursor:pointer;
  user-select:none;
  position:relative;
}
.tab.disabled::after{
  content:'✕';
  position:absolute;
  inset:0;
  display:grid;
  place-items:center;
  font-size:18px;
  font-weight:700;
  color:#b91c1c;
  pointer-events:none;
}
.tab.active{background:#111;color:#fff;border-color:#111;}
.bottom-pop .btn{
  background:#fff;
  color:#111;
  border-color:#111;
}
/* primaryの黒背景を上書き（念のため） */
.bottom-pop .btn.primary{
  background:#fff;
  color:#111;
  border-color:#111;
}

/* ★ プレイヤー円配置用 */
.player-circle{
  position:relative;
  width:260px;
  height:260px;
  margin:20px auto 0;
  border-radius:50%;
  border:none;
  box-sizing:border-box;
}
.player-circle::before{ content:''; }

.player-tag{
  position:absolute;
  transform:translate(-50%,-50%);
  padding:4px 8px;
  border-radius:999px;
  background:#f8f8f8;
  border:1px solid #ddd;
  font-size:12px;
  white-space:nowrap;
}
.player-tag.me{
  background:#111;
  color:#fff;
  border-color:#111;
}

/* ★ 投票済みプレイヤー（「自分が投票済み」の時だけ、他の投票済みの名前を黒に） */
.player-tag.voted-black{
  color:#111 !important;
  background:#fff;
  border-color:#111;
}

/* 他プレイヤーのミニカード（基本） */
.player-tag .mini-hand{
  position:absolute;
  left:50%;
  top:100%;
  transform:translate(-50%,3px);
  width:60px;
  height:30px;
  pointer-events:none;
}
.player-tag .mini-card{
  position:absolute;
  left:50%;
  top:0;
  width:16px;
  height:22px;
  border-radius:4px;
  border:1px solid rgba(255,255,255,.18); /* 外枠は控えめ */
  background:#000;                         /* ★ 黒塗り */
  font-size:10px;
  display:flex;
  align-items:center;
  justify-content:center;
  transform-origin:bottom center;
  box-shadow:0 2px 6px rgba(0,0,0,.15);
  box-sizing:border-box;
}

/* ★ 枠の内側に白い細い枠（裏向き用） */
.player-tag .mini-card.role-mini:not(.revealed)::after{
  content:'';
  position:absolute;
  inset:1px;
  border-radius:2px;
  border:1px solid rgba(255,255,255,.9);
  pointer-events:none;
}

/* ★ マスターのミニカード位置調整（左右2枚） */
.player-tag.is-master .mini-hand{ width:70px; }
/* 左側：mayor.jpg 用 */
.player-tag.is-master .mini-hand .mini-card.mayor-mini{ left:30%; }
/* 右側：役職ミニカード用 */
.player-tag.is-master .mini-hand .mini-card.role-mini{ left:70%; }

/* ★ 投票：自分が選んだ相手の上に ✉ */
.vote-mail{
  position:absolute;
  left:50%;
  top:-18px;
  transform:translateX(-50%);
  font-size:18px;
  line-height:1;
  filter:drop-shadow(0 2px 4px rgba(0,0,0,.2));
  pointer-events:none;
}

/* ★ 投票：票数表示（✉✉✉） */
.vote-count{
  position:absolute;
  left:50%;
  top:-18px;
  transform:translateX(-50%);
  font-size:16px;
  font-weight:900;
  letter-spacing:.08em;
  pointer-events:none;
  filter:drop-shadow(0 2px 4px rgba(0,0,0,.2));
}

/* 自分の手札 */
.my-hand-wrapper{ margin-top:16px;text-align:center; }
.my-hand-title{ display:none; }
.my-hand{
  display:flex;
  justify-content:center;
  gap:8px;
  margin-top:6px;
  min-height:100px;
}

/* ▼ 正体カード（自分） */
.my-card{
  width:60px;
  height:90px;
  border-radius:8px;
  border:1px solid #ddd;
  background:#fff;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:24px;
  font-weight:600;
  box-shadow:0 4px 12px rgba(0,0,0,.15);
}

/* ★ 正体カードを画像にする */
.my-card.role-card{
  position:relative;
  overflow:hidden;
  padding:0;
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
  color:transparent;
  text-shadow:none;
}

/* 追い出し確認 */
.dialog-backdrop{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.35);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:300;
}
.dialog-backdrop.hidden{ display:none; }
.dialog-box{
  background:#fff;
  border-radius:12px;
  padding:16px 18px;
  box-shadow:0 18px 40px rgba(0,0,0,.35);
  max-width:320px;
  width:calc(100% - 40px);
}
.dialog-box p{ margin:0 0 12px;font-size:14px;line-height:1.6; }
.dialog-buttons{ display:flex;justify-content:flex-end;gap:8px; }

/* ホスト設定ボタン */
.host-settings-btn{
  position:fixed;
  right:16px;
  bottom:16px;
  width:44px;
  height:44px;
  border-radius:50%;
  border:1px solid #ddd;
  background:#fff;
  box-shadow:0 8px 20px rgba(0,0,0,.18);
  display:none;
  align-items:center;
  justify-content:center;
  font-size:22px;
  cursor:pointer;
  z-index:230;
}
.host-settings-btn.visible{ display:flex; }

/* スタートポップ */
.start-pop{
  position:fixed;
  right:16px;
  bottom:72px;
  background:#fff;
  border:1px solid #ddd;
  border-radius:12px;
  box-shadow:0 12px 28px rgba(0,0,0,.16);
  padding:10px 12px;
  z-index:240;
  min-width:240px;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.start-pop.hidden{ display:none; }
.start-pop-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:8px;
}
.start-pop-title{ font-size:14px;font-weight:600; }
.start-pop-main{ font-size:13px;line-height:1.5; }
.start-pop-actions{
  display:flex;
  justify-content:flex-end;
  gap:8px;
  margin-top:4px;
}

/* ロビー中央配置 */
#roomInfoLobby,#lobby h2,#lobby p{ display:none; }
#lobby.entered{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  min-height:calc(100vh - 60px);
}

/* マスターポップ */
.master-pop{
  position:fixed;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  background:#fff;
  border-radius:12px;
  padding:16px 18px;
  box-shadow:0 18px 40px rgba(0,0,0,.35);
  z-index:260;
  min-width:260px;
  display:flex;
  flex-direction:column;
  gap:10px;
}
.master-pop.hidden{ display:none; }
.master-pop-title{ font-size:14px;font-weight:600; }
.master-pop-choices{ display:flex;flex-direction:column;gap:8px; }
.master-pop-choices .btn{ width:100%;text-align:center; }

/* タイマー：main内絶対配置 */
.timer-wrapper{
  position:absolute;
  right:16px;
  top:8px;
  z-index:250;
}
.timer-wrapper.hidden{ display:none; }
.timer-circle{
  position:relative;
  width:72px;
  height:72px;
  border-radius:50%;
  background:#fff; /* ベースは白 */
  display:flex;
  align-items:center;
  justify-content:center;
}

/* ★ 線（短い目盛り）を内側リングにだけ描く */
.timer-circle::before{
  content:'';
  position:absolute;
  inset:3px;
  border-radius:50%;
  background:
    repeating-conic-gradient(
      from 0deg,
      #111 0deg 2deg,
      transparent 2deg 45deg
    );
  -webkit-mask: radial-gradient(circle, transparent 58%, #000 59%);
          mask: radial-gradient(circle, transparent 58%, #000 59%);
}

/* 中央の白丸 */
.timer-circle::after{
  content:'';
  position:absolute;
  inset:18px;
  border-radius:50%;
  background:#fff;
  z-index:0;
}

#timerText{
  position:relative;
  font-size:16px;
  font-weight:700;
  color:#111;
  z-index:1;
}

/* =========================
   ★ お題ボード
   ========================= */
.topic-board{
  position:absolute;
  left:50%;
  top:290px;
  transform:translateX(-50%);
  z-index:10;
  width:140px;
  height:80px;
  pointer-events:none;
}
.topic-board.hidden{ display:none; }

.topic-board-inner{
  position:relative;
  width:100%;
  height:100%;
  border-radius:10px;
  box-shadow:0 18px 40px rgba(0,0,0,.35);
  overflow:hidden;
  display:flex;
}

/* 権限あり：二重線枠 */
.topic-board-inner.white{
  background:#fff;
  padding:10px;
  border-radius:10px;
  border:3px solid #111;
  position:relative;
  width:100%;
  height:100%;
  box-sizing:border-box;
}
.topic-board-inner.white::before{
  content:'';
  position:absolute;
  inset:2px;
  border-radius:5px;
  border:2px solid #111;
  pointer-events:none;
  background:transparent;
}

/* 権限なし：茶 */
.topic-board-inner.brown{
  background:linear-gradient(135deg,#8b5a2b,#6f3f1d);
  border:4px solid rgba(255,255,255,.18);
  width:100%;
  height:100%;
  box-sizing:border-box;
}

/* 中の板 */
.topic-board-panel{
  position:relative;
  border-radius:10px;
  padding:0;
  width:100%;
  height:100%;
  box-sizing:border-box;
  display:flex;
  align-items:center;
  justify-content:center;
  background:#fff;
}
.topic-board-inner.brown .topic-board-panel{
  background:rgba(0,0,0,.08);
}

/* 文字：自動縮小 */
.topic-board-text{
  font-size:22px;
  font-weight:800;
  letter-spacing:.06em;
  color:#111;
  text-align:center;

  display:flex;
  align-items:center;
  justify-content:center;
  width:100%;
  height:100%;

  padding:10px 12px;
  box-sizing:border-box;

  line-height:1.12;
  white-space:normal;
  overflow-wrap:anywhere;
}

/* =========================
   ★ マスター用：正解!! 丸ボタン
   ========================= */
.correct-btn{
  position:fixed;
  left:50%;
  bottom:16px;
  transform:translateX(-50%);
  width:84px;
  height:84px;
  border-radius:50%;
  border:2px solid #111;
  background:#5C3B54;
  color:#fff;
  font-size:16px;
  font-weight:900;
  box-shadow:0 12px 28px rgba(0,0,0,.22);
  cursor:pointer;
  z-index:270;
}
.correct-btn:active{ transform:translateX(-50%) scale(.98); }

/* =========================
   ★ 下部黒ポップ（黒背景白字）
   ========================= */
.bottom-pop{
  position:fixed;
  left:50%;
  bottom:16px;
  transform:translateX(-50%);
  background:#111;
  color:#fff;
  border:1px solid rgba(255,255,255,.18);
  border-radius:14px;
  padding:12px 14px;
  box-shadow:0 18px 40px rgba(0,0,0,.35);
  z-index:999;
  min-width:280px;
  max-width:min(520px, calc(100vw - 24px));
  display:flex;
  flex-direction:column;
  gap:10px;
}
.bottom-pop.hidden{ display:none; }
.bottom-pop-text{ font-size:14px; font-weight:700; line-height:1.45; }
.bottom-pop-actions{
  display:flex;
  justify-content:flex-end;
  gap:8px;
}
.bottom-pop-actions.hidden{ display:none; }

/* =========================
   ★ ミニカード：公開状態（1.6倍）
   ========================= */
.player-tag .mini-card.revealed{
  width: calc(16px * 1.6);
  height: calc(22px * 1.6);
  border-radius:6px;
  border:1px solid rgba(0,0,0,.25);
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
  box-shadow:0 8px 18px rgba(0,0,0,.22);
}

/* =========================
   ★ 画面中央の拡大カード + 揺れ
   ========================= */
.center-reveal{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,.18);
  z-index:1000;
  pointer-events:none;
}
.center-reveal.hidden{ display:none; }

/* 単体 */
.center-reveal-card{
  width:220px;
  height:330px;
  border-radius:16px;
  border:1px solid rgba(0,0,0,.18);
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
  box-shadow:0 28px 70px rgba(0,0,0,.35);
  animation:quickShake 2s ease-in-out both;
}

/* 2枚用（横並び） */
.center-reveal-row{ display:flex; gap:18px; }
.center-reveal-card.small{ width:200px; height:300px; }

@keyframes quickShake{
  0%{ transform:translateY(0) rotate(0deg) scale(1); }
  10%{ transform:translateY(-2px) rotate(-2deg) scale(1.02); }
  20%{ transform:translateY(2px) rotate(2deg) scale(1.02); }
  35%{ transform:translateY(-2px) rotate(-1.5deg) scale(1.02); }
  50%{ transform:translateY(2px) rotate(1.5deg) scale(1.02); }
  70%{ transform:translateY(-1px) rotate(-1deg) scale(1.01); }
  85%{ transform:translateY(1px) rotate(1deg) scale(1.01); }
  100%{ transform:translateY(0) rotate(0deg) scale(1); }
}

/* ★ ギリギリポップ用：中央表示＋白背景黒文字 */
.bottom-pop.giri{
  top:50%;
  bottom:auto;
  transform:translate(-50%, -50%);
  background:#fff;
  color:#111;
  border:1px solid #111;
}

/* =========================
   ★ TIME UP! ポップ
   ========================= */
.timeup-pop{
  position:fixed;
  left:50%;
  top:50%;
  transform:translate(-160%,-50%);
  padding:14px 32px;
  border-radius:999px;
  background:#111;
  color:#fff;
  font-size:28px;
  font-weight:900;
  letter-spacing:.16em;
  text-transform:uppercase;
  box-shadow:0 18px 40px rgba(0,0,0,.35);
  z-index:2147483647;
  white-space:nowrap;
  pointer-events:none;
  opacity:0;
}
.timeup-pop.show{ animation:timeupSlide 1.6s cubic-bezier(.22,.84,.44,1) both; }
@keyframes timeupSlide{
  0%{ transform:translate(-160%,-50%); opacity:0; }
  30%{ transform:translate(-50%,-50%); opacity:1; }
  60%{ transform:translate(-50%,-50%); opacity:1; }
  100%{ transform:translate(160%,-50%); opacity:0; }
}

/* ★ 自分の✉（投票マーク/票数）だけ黒にする */
.player-tag.me .vote-mail,
.player-tag.me .vote-count{ color:#111 !important; }

/* ★ 入室後のmain背景 */
body.in-room main{
  background-image: url("wereback.jpg");
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  background-attachment: local;
}

/* =========================
   ★ 左下：? ヘルプボタン
   ========================= */
.help-btn{
  position:fixed;
  left:16px;
  bottom:16px;
  width:44px;
  height:44px;
  border-radius:50%;
  border:2px solid #111;
  background:#111;
  color:#fff;
  font-size:22px;
  font-weight:900;
  line-height:1;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  z-index:1200;
  box-shadow:0 8px 20px rgba(0,0,0,.18);
  display:none;
}
body.in-room .help-btn{
  display:flex;
}
.help-btn:active{ transform:scale(.98); }

/* =========================
   ★ ヘルプ：広いポップ（モーダル）
   ========================= */
.help-modal{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.35);
  z-index:1300;
  display:flex;
  align-items:flex-end;
  justify-content:center;
  padding:14px;
}
.help-modal.hidden{ display:none; }

.help-panel{
  width:min(720px, calc(100vw - 24px));
  max-height:min(74vh, 560px);
  overflow:auto;
  -webkit-overflow-scrolling:touch;

  background:#fff;
  border:1px solid rgba(0,0,0,.18);
  border-radius:16px;
  box-shadow:0 22px 60px rgba(0,0,0,.35);
  padding:14px 14px 10px;
}

.help-header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin-bottom:10px;
}
.help-title{
  font-size:14px;
  font-weight:900;
  color:#111;
}
.help-close{
  width:32px;
  height:32px;
  border-radius:10px;
  border:1px solid #111;
  background:#fff;
  color:#111;
  cursor:pointer;
  font-weight:900;
}

.help-list{
  display:flex;
  flex-direction:column;
  gap:10px;
}

.help-row{
  display:flex;
  gap:12px;
  align-items:flex-start;
  text-align:left;
}
.help-row img{
  width:72px;
  height:108px;
  border-radius:10px;
  border:1px solid rgba(0,0,0,.18);
  object-fit:cover;
  flex:0 0 auto;
}
.help-text{
  flex:1 1 auto;
}
.help-role{
  font-weight:900;
  margin-bottom:4px;
}
.help-desc{
  font-size:13px;
  line-height:1.55;
  color:#111;
  white-space:pre-wrap;
}

/* ★ 入室前のmain背景（デフォルト） */
body:not(.in-room) main{
  background-image: url("weretop.jpg");
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  background-attachment: local;
}
</style>
</head>
<body>

<header>
  <h1>テンプレ</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">リンクコピー</button>
  </div>
</header>

<main>
  <div id="timerBox" class="timer-wrapper hidden">
    <div class="timer-circle">
      <div id="timerText">4:00</div>
    </div>
  </div>

  <!-- ★ お題ボード -->
  <div id="topicBoard" class="topic-board hidden">
    <div id="topicBoardInner" class="topic-board-inner brown">
      <div class="topic-board-panel">
        <div id="topicBoardText" class="topic-board-text"></div>
      </div>
    </div>
  </div>

  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>
    <div id="playerCircle" class="player-circle"></div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">自分のカード</div>
      <div id="myHand" class="my-hand"></div>
    </div>
  </div>
</main>

<!-- ★ TIME UP! ポップ -->
<div id="timeupPop" class="timeup-pop hidden">TIME UP!</div>

<!-- マスター用：正解!! ボタン -->
<button id="btnCorrect" class="correct-btn hidden">正解!!</button>

<!-- 画面下部：黒背景白字ポップ -->
<div id="bottomPop" class="bottom-pop hidden">
  <div id="bottomPopText" class="bottom-pop-text"></div>
  <div id="bottomPopActions" class="bottom-pop-actions hidden">
    <button id="btnGuessNo" class="btn ghost">いいえ</button>
    <button id="btnGuessYes" class="btn primary">はい</button>
  </div>
</div>

<!-- 中央：拡大カード演出 -->
<div id="centerReveal" class="center-reveal hidden">
  <div id="centerRevealRow" class="center-reveal-row">
    <div id="centerRevealCardA" class="center-reveal-card"></div>
    <div id="centerRevealCardB" class="center-reveal-card small hidden"></div>
  </div>
</div>

<!-- 席ポップ -->
<div id="seatPop" class="seat-pop hidden">
  <div class="row">
    <label>席を選択</label>
    <div id="seatTabs" class="tabs"></div>
  </div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<!-- 追い出しダイアログ -->
<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ゲームスタート</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    準備ができたら「スタート」を押してください。<br>
    押すと全プレイヤーにカードが1枚ずつ配られます。
  </div>
  <div class="start-pop-actions">
    <button id="btnGameReset" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<div id="masterPop" class="master-pop hidden">
  <div class="master-pop-title">お題を選んでください</div>
  <div id="masterChoices" class="master-pop-choices"></div>
</div>

<!-- ★ 左下：? ボタン -->
<button id="helpBtn" class="help-btn" title="役職の説明">？</button>

<!-- ★ ヘルプ：広いポップ -->
<div id="helpModal" class="help-modal hidden">
  <div class="help-panel" role="dialog" aria-modal="true" aria-label="役職の説明">
    <div class="help-header">
      <div class="help-title">役職の説明</div>
      <button id="helpClose" class="help-close">×</button>
    </div>

    <div class="help-list">
      <div class="help-row">
        <img src="villager.jpg" alt="村人">
        <div class="help-text">
          <div class="help-role">村人</div>
          <div class="help-desc">お題を当てることができれば、勝ち</div>
        </div>
      </div>

      <div class="help-row">
        <img src="seer.jpg" alt="占い師">
        <div class="help-text">
          <div class="help-role">占い師</div>
          <div class="help-desc">お題を当てることができれば、勝ち。お題を知っているが、狼に自分の正体がばれてはいけない。</div>
        </div>
      </div>

      <div class="help-row">
        <img src="wolf.jpg" alt="狼">
        <div class="help-text">
          <div class="help-role">狼</div>
          <div class="help-desc">誰もお題を当てられなければ、勝ち。お題を知っている。お題が当てられた時、占い師が誰か言い当てられたら、逆転勝利。</div>
        </div>
      </div>

      <div class="help-row">
        <img src="beholder.jpg" alt="千里眼">
        <div class="help-text">
          <div class="help-role">千里眼</div>
          <div class="help-desc">誰が占い師か知っている。</div>
        </div>
      </div>

      <div class="help-row">
        <img src="thing.jpg" alt="なにか">
        <div class="help-text">
          <div class="help-role">なにか</div>
          <div class="help-desc">左隣の人は自分の正体を知っている。それ以外は何もない。</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, set, get, update, onValue } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyDOy6I4Mo1vx4sthNZXtGLibeXwVsV1yVE",
  authDomain: "werewords-e5e0d.firebaseapp.com",
  databaseURL: "https://werewords-e5e0d-default-rtdb.firebaseio.com/",
  projectId: "werewords-e5e0d",
  storageBucket: "werewords-e5e0d.firebasestorage.app",
  messagingSenderId: "838829721686",
  appId: "1:838829721686:web:64f61d2c9d100a863793f7",
  measurementId: "G-0HCGLMFZQ2"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  hostId: null,

  hands: {},
  masterId: null,
  masterChoices: [],
  masterChosen: null,

  // 公開フロー
  reveal: null,
  _guessPendingTargetId: null,
  _handledRevealKey: null,

  // 全員公開のタイマー
  _allRevealTimerId: null,
  _commitAllTimerId: null,

  // ★ ボード全体公開フラグ & 下部ポップのモード
  boardOpenToAll: false,
  bottomMode: null,      // 'correct' | 'wolf' | 'vote' | 'hostSelecting' | null

  // ★ 投票フェーズ
  vote: null,
  _voteLocalTick: null,
  _handledVoteResultKey: null,

  // ★ 席ポップを「観戦」で閉じたら自動で開き直さない
  seatPopDismissed: false,

  // ★ 追加：全員公開アニメを1回だけ
  _handledAllRevealAnimKey: null,
  _handledTimeupKey: null,

  // ★ 追加：ゲーム再スタート合図（全員のUIを強制リセット）
  gameKey: null,

  // ★ 追加：0秒になったら「正解!!」ボタンを再スタートまで封印
  correctBtnLocked: false,
};

const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnGameReset = document.getElementById('btnGameReset');

const masterPop = document.getElementById('masterPop');
const masterChoicesEl = document.getElementById('masterChoices');

const timerBox = document.getElementById('timerBox');
const timerText = document.getElementById('timerText');

const topicBoard = document.getElementById('topicBoard');
const topicBoardInner = document.getElementById('topicBoardInner');
const topicBoardText = document.getElementById('topicBoardText');

/* 正解!!ボタン */
const btnCorrect = document.getElementById('btnCorrect');

/* 下部ポップ＆中央演出 */
const bottomPop = document.getElementById('bottomPop');
const bottomPopText = document.getElementById('bottomPopText');
const bottomPopActions = document.getElementById('bottomPopActions');
const btnGuessYes = document.getElementById('btnGuessYes');
const btnGuessNo  = document.getElementById('btnGuessNo');

const centerReveal = document.getElementById('centerReveal');
const centerRevealCardA = document.getElementById('centerRevealCardA');
const centerRevealCardB = document.getElementById('centerRevealCardB');

/* ★ TIME UP! ポップ */
const timeupPop = document.getElementById('timeupPop');

/* =========================
   ★ ヘルプ（?）ポップ
   ========================= */
const helpBtn   = document.getElementById('helpBtn');
const helpModal = document.getElementById('helpModal');
const helpClose = document.getElementById('helpClose');

function openHelp(){ helpModal?.classList.remove('hidden'); }
function closeHelp(){ helpModal?.classList.add('hidden'); }

helpBtn?.addEventListener('click', () => {
  if (!helpModal) return;
  if (helpModal.classList.contains('hidden')) openHelp();
  else closeHelp();
});
helpClose?.addEventListener('click', closeHelp);

/* 背景クリックで閉じる */
helpModal?.addEventListener('click', (e) => {
  if (e.target === helpModal) closeHelp();
});

/* ESCで閉じる */
window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') closeHelp();
});

let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;
let latestPlayers = [];

let latestTablesRaw = {};  // ★ tables を保持
let latestRoomMeta  = {};  // ★ maxPlayers など

let timerInterval = null;
let currentTimerKey = null;

/* =========================================================
   ★ 追加：ホスト人数選択中か？
   - maxPlayers未設定なら「ホスト人数選択中」
   ========================================================= */
function isHostSelectingNow(){
  return !latestRoomMeta?.maxPlayers;
}

/* =========================================================
   ★ 追加：ホスト人数選択中は席ポップを非表示（非ホストだけ）
   ========================================================= */
function syncSeatPopVisibility(){
  if (!seatPop) return;
  if (isHostSelectingNow() && !state.isHost){
    seatPop.classList.add('hidden');
    return;
  }
}

/* =========================================================
   ★ 追加：ギリギリ表示中は「正解!!」ボタンを隠す
   ★ 追加：0秒到達後は「正解!!」ボタンを再スタートまで封印
   ========================================================= */
function updateCorrectBtnVisibility(){
  if (!btnCorrect) return;

  const isMaster = (state.userId === state.masterId);
  const hasChosen = !!state.masterChosen;

  const giriVisible =
    bottomPop && !bottomPop.classList.contains('hidden') && bottomPop.classList.contains('giri');

  const shouldShow = isMaster && hasChosen && !giriVisible && !state.correctBtnLocked;
  btnCorrect.classList.toggle('hidden', !shouldShow);
}

/* =========================================================
   ★ 追加：再スタート時に「出ているポップ全部」をローカルで強制リセット
   ========================================================= */
function resetAllPopsLocal(){
  hideBottomPop();
  hideCenterReveal();

  // TIMEUPを強制消去
  if (timeupPop){
    timeupPop.classList.add('hidden');
    timeupPop.classList.remove('show');
  }

  // ヘルプも閉じる
  closeHelp();

  // タイマー/公開/投票のローカルタイマー停止
  stopTimer();
  clearRevealTimers();
  clearVoteLocalTick();

  // ハンドルキー類もリセット
  state._guessPendingTargetId = null;
  state.bottomMode = null;

  state._handledRevealKey = null;
  state._handledVoteResultKey = null;
  state._handledAllRevealAnimKey = null;
  state._handledTimeupKey = null;

  // ★ 0秒封印を解除（再スタートで戻す）
  state.correctBtnLocked = false;

  // ボタン整合
  updateCorrectBtnVisibility();
}

/* =========================================================
   ★ 追加：gameKey を購読して、変わったら全員でUIを強制リセット
   ========================================================= */
function subscribeGameKey(){
  if (!state.roomCode) return;
  const gRef = ref(db, `rooms/${state.roomCode}/gameKey`);
  onValue(gRef, snap => {
    const key = snap.val() || null;
    if (!key) return;

    // 初回は記録だけ
    if (state.gameKey === null){
      state.gameKey = key;
      return;
    }

    if (state.gameKey !== key){
      state.gameKey = key;
      resetAllPopsLocal();
      renderHands();
      renderTopicBoard();
      updateHostSelectingPop();
      syncSeatPopVisibility();
    }
  });
}

/* ▼ 0秒になったときのローカル処理 */
function onTimerEndLocal(){
  showTimeupPop();

  // ★ 0秒時点で正解ボタンを非表示＆再スタートまで再表示しない
  state.correctBtnLocked = true;
  updateCorrectBtnVisibility();

  setTimeout(() => {
    if (state.userId !== state.masterId) return;
    if (!state.masterChosen) return;
    if (state.boardOpenToAll) return;
    if (state.reveal && state.reveal.phase) return;
    if (state.vote && state.vote.phase) return;

    // ★ ギリギリポップが開く＝「誰かが正解しましたか？」を強制的に一度だけ閉じる
    if (!bottomPop.classList.contains('hidden') && state.bottomMode === 'correct' && !bottomPop.classList.contains('giri')){
      hideBottomPop();
    }

    state.bottomMode = 'correct';
    showBottomPop('ギリギリで正解したプレイヤーがいますか？', true);
  }, 500);
}

function clearRevealTimers(){
  if (state._allRevealTimerId){
    clearTimeout(state._allRevealTimerId);
    state._allRevealTimerId = null;
  }
  if (state._commitAllTimerId){
    clearTimeout(state._commitAllTimerId);
    state._commitAllTimerId = null;
  }
}

function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function stopTimer(){
  if (timerInterval){
    clearInterval(timerInterval);
    timerInterval = null;
  }
  currentTimerKey = null;
  if (timerBox) timerBox.classList.add('hidden');
}

function startLocalTimer(chosenAt, durationSec){
  if (!chosenAt || !durationSec || !timerBox || !timerText) return;

  const key = `${chosenAt}-${durationSec}`;

  // ★ まだ同じタイマーを表示中なら再起動しない
  if (currentTimerKey === key) return;
  currentTimerKey = key;

  if (timerInterval){
    clearInterval(timerInterval);
    timerInterval = null;
  }

  const endTime = chosenAt + durationSec * 1000;
  let done = false;

  function tick(){
    const now = Date.now();
    let remainMs = endTime - now;
    if (remainMs < 0) remainMs = 0;

    const totalSec = Math.floor(remainMs / 1000);
    const min = Math.floor(totalSec / 60);
    const sec = totalSec % 60;
    timerText.textContent = `${min}:${sec.toString().padStart(2,'0')}`;

    if (remainMs <= 0){
      if (!done){
        done = true;

        clearInterval(timerInterval);
        timerInterval = null;

        // ★ 重要：TIMEUPは同じkeyで1回だけ
        if (state._handledTimeupKey !== key){
          state._handledTimeupKey = key;
          onTimerEndLocal();
        }
      }
    }
  }

  timerBox.classList.remove('hidden');
  tick();
  timerInterval = setInterval(tick, 1000);
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = `ルーム: ${state.roomCode}, 名前: ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}

function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
}

/* ★ 人数未選択中：非ホストには黒ポップを出す */
function updateHostSelectingPop(){
  const inRoom = document.body.classList.contains('in-room');
  if (!inRoom) return;

  const maxPlayers = latestRoomMeta?.maxPlayers || null;

  const someFlow =
    (state.reveal && state.reveal.phase) ||
    (state.vote && state.vote.phase) ||
    !!state.masterChosen ||
    (state.bottomMode === 'correct' || state.bottomMode === 'wolf' || state.bottomMode === 'vote');

  if (someFlow) return;

  if (!maxPlayers && !state.isHost){
    state.bottomMode = 'hostSelecting';
    showBottomPop('ホストが人数を選択中…', false);
  } else {
    if (state.bottomMode === 'hostSelecting'){
      hideBottomPop();
    }
  }
}

function subscribeHostState(){
  if (!state.roomCode) return;
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.hostId = hostId || null;
    state.isHost = (hostId === state.userId);
    updateHostUI();
    updateHostSelectingPop();
    syncSeatPopVisibility();
    updateCorrectBtnVisibility();
  });
}

/* ★ 部屋メタ（maxPlayersなど）購読：席選択を同期更新 */
function subscribeRoomMeta(){
  if (!state.roomCode) return;

  let prevMaxPlayers = null;

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, async snap => {
    const before = prevMaxPlayers;
    latestRoomMeta = snap.val() || {};
    const nowMax = latestRoomMeta?.maxPlayers || null;
    prevMaxPlayers = nowMax;

    updateHostSelectingPop();
    syncSeatPopVisibility();

    if (!before && nowMax && state.seatedTable === null && !state.seatPopDismissed){
      await renderSeatTabsLive(latestRoomMeta, latestTablesRaw);
      seatPop.classList.remove('hidden');
      syncSeatPopVisibility();
    }

    if (state.seatedTable === null && !state.seatPopDismissed && !seatPop.classList.contains('hidden')){
      renderSeatTabsLive(latestRoomMeta, latestTablesRaw);
      syncSeatPopVisibility();
    }
  });
}

function getMyRole(){
  const my = state.hands?.[state.userId];
  return (my && Array.isArray(my.cards) && my.cards[0]) ? my.cards[0] : null;
}

/* お題テキストの自動縮小 */
function fitTopicText(){
  if (!topicBoard || !topicBoardText) return;
  if (topicBoard.classList.contains('hidden')) return;
  if (!topicBoardText.textContent) return;

  const panel = topicBoardText.closest('.topic-board-panel');
  if (!panel) return;

  const base = 22;
  const min  = 8;

  const tryFit = () => {
    let size = base;
    topicBoardText.style.fontSize = size + 'px';

    while (
      size > min &&
      (topicBoardText.scrollWidth  > panel.clientWidth ||
       topicBoardText.scrollHeight > panel.clientHeight)
    ){
      size -= 1;
      topicBoardText.style.fontSize = size + 'px';
    }
  };

  requestAnimationFrame(() => {
    tryFit();
    requestAnimationFrame(() => {
      tryFit();
      setTimeout(tryFit, 0);
    });
  });
}
window.addEventListener('resize', fitTopicText);

function renderTopicBoard(){
  if (!topicBoard || !topicBoardInner || !topicBoardText) return;

  const chosen = state.masterChosen;
  if (!chosen){
    topicBoard.classList.add('hidden');
    return;
  }

  const myRole = getMyRole();
  const isPrivileged =
    state.boardOpenToAll ||
    (state.userId === state.masterId) ||
    (myRole === '占い師') ||
    (myRole === '狼');

  topicBoard.classList.remove('hidden');

  if (isPrivileged){
    topicBoardInner.classList.remove('brown');
    topicBoardInner.classList.add('white');
    topicBoardText.textContent = chosen;
  } else {
    topicBoardInner.classList.remove('white');
    topicBoardInner.classList.add('brown');
    topicBoardText.textContent = '';
  }

  fitTopicText();
}

function subscribeHands(){
  if (!state.roomCode) return;
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    renderHands();
    renderTopicBoard();
  });
}

function subscribeMaster(){
  if (!state.roomCode) return;
  const mRef = ref(db, `rooms/${state.roomCode}/master`);
  onValue(mRef, snap => {
    const m = snap.val();

    if (!m || !m.id) {
      state.masterId = null;
      state.masterChoices = [];
      state.masterChosen = null;
      state.boardOpenToAll = false;

      // ★ masterが消える（リセット等）時は封印解除（gameKeyでも解除されるが保険）
      state.correctBtnLocked = false;

      masterPop.classList.add('hidden');
      stopTimer();
      renderTopicBoard();
      updateCorrectBtnVisibility();
      renderHands();

      updateHostSelectingPop();
      syncSeatPopVisibility();
      return;
    }

    state.masterId = m.id;
    state.masterChoices = Array.isArray(m.choices) ? m.choices : [];
    state.boardOpenToAll = !!m.boardOpenToAll;

    const alreadyChosen = !!m.chosen;

    if (state.userId === state.masterId && !alreadyChosen) {
      renderMasterPop();
    } else {
      masterPop.classList.add('hidden');
    }

    if (m.timerPaused) {
      stopTimer();
    } else if (m.chosenAt && m.durationSec) {
      startLocalTimer(m.chosenAt, m.durationSec);
    } else {
      stopTimer();
    }

    state.masterChosen = m.chosen || null;
    renderTopicBoard();

    updateCorrectBtnVisibility();

    renderHands();
    updateHostSelectingPop();
    syncSeatPopVisibility();
  });
}

function renderMasterPop(){
  masterChoicesEl.innerHTML = '';
  const choices = state.masterChoices;
  if (!choices || !choices.length) return;

  choices.forEach(word => {
    const btn = document.createElement('button');
    btn.className = 'btn';
    btn.textContent = word;

    btn.onclick = async () => {
      if (!state.roomCode) return;

      const durationSec = 1 * 5;
      const chosenAt = Date.now();

      const mRef = ref(db, `rooms/${state.roomCode}/master`);
      state._handledTimeupKey = null;
      await update(mRef, { chosen: word, chosenAt, durationSec, timerPaused:false });

      startLocalTimer(chosenAt, durationSec);
      masterPop.classList.add('hidden');
    };

    masterChoicesEl.appendChild(btn);
  });

  masterPop.classList.remove('hidden');
}

/* 役職 → 画像ファイル */
function roleToImage(role){
  const map = {
    '占い師': 'seer.jpg',
    '千里眼': 'beholder.jpg',
    '狼':     'wolf.jpg',
    '村人':   'villager.jpg',
    'なにか': 'thing.jpg',
  };
  return map[role] || 'thing.jpg';
}

/* 下部ポップ/中央演出 */
function hideBottomPop(){
  bottomPop?.classList.add('hidden');
  bottomPopActions?.classList.add('hidden');
  state._guessPendingTargetId = null;
  state.bottomMode = null;
  updateCorrectBtnVisibility();
}
function showBottomPop(text, withActions=false){
  if (!bottomPop || !bottomPopText || !bottomPopActions) return;
  bottomPopText.textContent = text;

  const isGiri = text.startsWith('ギリギリで正解したプレイヤーがいますか？');
  bottomPop.classList.toggle('giri', isGiri);

  bottomPop.classList.remove('hidden');
  bottomPopActions.classList.toggle('hidden', !withActions);

  updateCorrectBtnVisibility();
}

function hideCenterReveal(){
  centerReveal?.classList.add('hidden');
  centerRevealCardB?.classList.add('hidden');
}
function showCenterRevealSingle(role){
  const img = roleToImage(role);
  centerRevealCardA.style.backgroundImage = `url("${img}")`;
  centerRevealCardA.classList.remove('small');
  centerRevealCardA.style.animation = 'none';
  centerRevealCardA.offsetHeight;
  centerRevealCardA.style.animation = '';
  centerRevealCardB.classList.add('hidden');
  centerReveal.classList.remove('hidden');
}
function showCenterRevealDouble(roleA, roleB){
  centerRevealCardA.style.backgroundImage = `url("${roleToImage(roleA)}")`;
  centerRevealCardA.classList.add('small');
  centerRevealCardA.style.animation = 'none';
  centerRevealCardA.offsetHeight;
  centerRevealCardA.style.animation = '';

  centerRevealCardB.style.backgroundImage = `url("${roleToImage(roleB)}")`;
  centerRevealCardB.classList.remove('hidden');
  centerRevealCardB.style.animation = 'none';
  centerRevealCardB.offsetHeight;
  centerRevealCardB.style.animation = '';

  centerReveal.classList.remove('hidden');
}

/* TIME UP! ポップ表示（全員ローカル） */
function showTimeupPop(){
  if (!timeupPop) return;
  timeupPop.classList.remove('hidden');
  timeupPop.classList.remove('show');
  void timeupPop.offsetWidth;
  timeupPop.classList.add('show');

  setTimeout(() => {
    timeupPop.classList.add('hidden');
    timeupPop.classList.remove('show');
  }, 1700);
}

function getWolfIdFromHands(){
  const entries = Object.entries(state.hands || {});
  for (const [uid, hand] of entries){
    const role = hand?.cards?.[0];
    if (role === '狼') return uid;
  }
  return null;
}

function isRevealWolfCard(uid){
  const r = state.reveal;
  if (!r) return false;
  return r.phase === 'wolf' && r.wolfId === uid;
}
function isRevealTargetCard(uid){
  const r = state.reveal;
  if (!r) return false;
  if (r.phase !== 'target') return false;
  return r.targetId === uid;
}

/* allAt を優先 */
function isAllRevealActive(){
  const r = state.reveal;
  if (!r) return false;
  if (r.phase === 'all') return true;

  const at = (typeof r.allAt === 'number')
    ? r.allAt
    : (r.phase === 'target' && r.t0 ? (r.t0 + 5000) : null);

  return (typeof at === 'number') ? (Date.now() >= at) : false;
}

/* ★ 次の手番（席順で次）のプレイヤー判定：viewerId が targetId の次なら true */
function isNextTurnPlayerOf(viewerId, targetId){
  if (!viewerId || !targetId) return false;
  if (!Array.isArray(latestPlayers) || latestPlayers.length < 2) return false;

  const idx = latestPlayers.findIndex(p => p.id === targetId);
  if (idx < 0) return false;

  const next = latestPlayers[(idx + 1) % latestPlayers.length];
  return next?.id === viewerId;
}

/* ★ 千里眼の人は占い師のミニ正体カードを常に表で見る */
function shouldRevealRoleForPlayer(uid){
  const myRole = getMyRole();
  const targetHand = state.hands?.[uid];
  const targetRole = targetHand?.cards?.[0];

  // ★ なにか の次の手番プレイヤーは、なにか の正体が見える
  if (targetRole === 'なにか' && isNextTurnPlayerOf(state.userId, uid)) return true;

  if (myRole === '千里眼' && targetRole === '占い師') return true;
  if (isAllRevealActive()) return true;
  if (isRevealWolfCard(uid)) return true;
  if (isRevealTargetCard(uid)) return true;
  return false;
}

async function stealSeatState(oldId, newId){
  if (!state.roomCode || !oldId || !newId) return;

  const base = `rooms/${state.roomCode}`;
  const roomSnap = await get(ref(db, base));
  const room = roomSnap.val() || {};

  const updates = {};

  if (room.hands && room.hands[oldId]) {
    updates[`${base}/hands/${newId}`] = room.hands[oldId];
    updates[`${base}/hands/${oldId}`] = null;
  }

  if (room.master && room.master.id === oldId) {
    updates[`${base}/master/id`] = newId;
  }

  if (room.reveal) {
    const r = room.reveal;
    if (r.wolfId === oldId) updates[`${base}/reveal/wolfId`] = newId;
    if (r.targetId === oldId) updates[`${base}/reveal/targetId`] = newId;
  }

  if (room.vote) {
    const v = room.vote;

    if (Array.isArray(v.expectedVoters) && v.expectedVoters.includes(oldId)) {
      const replaced = v.expectedVoters.map(id => id === oldId ? newId : id);
      updates[`${base}/vote/expectedVoters`] = replaced;
    }

    if (v.votes && v.votes[oldId]) {
      updates[`${base}/vote/votes/${newId}`] = v.votes[oldId];
      updates[`${base}/vote/votes/${oldId}`] = null;
    }

    if (v.votes) {
      for (const [voterId, targetId] of Object.entries(v.votes)) {
        if (targetId === oldId) {
          updates[`${base}/vote/votes/${voterId}`] = newId;
        }
      }
    }

    if (v.counts && typeof v.counts === 'object') {
      if (v.counts[oldId] != null) {
        const c = v.counts[oldId];
        updates[`${base}/vote/counts/${newId}`] = (v.counts[newId] || 0) + c;
        updates[`${base}/vote/counts/${oldId}`] = null;
      }
    }
    if (Array.isArray(v.winners) && v.winners.includes(oldId)) {
      updates[`${base}/vote/winners`] = v.winners.map(id => id === oldId ? newId : id);
    }
  }

  if (room.hostId === oldId) {
    updates[`${base}/hostId`] = newId;
  }

  if (Object.keys(updates).length) {
    await update(ref(db), updates);
  }
}

function renderRevealUI(){
  const r = state.reveal;

  if (!r || !r.phase){
    clearRevealTimers();
    if (state.bottomMode !== 'vote' && state.bottomMode !== 'hostSelecting') hideBottomPop();
    hideCenterReveal();
    updateHostSelectingPop();
    syncSeatPopVisibility();
    return;
  }

  if (r.phase === 'wolf'){
    clearRevealTimers();
    hideCenterReveal();
    if (state.userId === r.wolfId){
      showBottomPop('誰が占い師？ネームタグをクリック', false);
    } else {
      showBottomPop('狼が考え中…', false);
    }
    return;
  }

  if (r.phase === 'target'){
    hideBottomPop();

    const key = `${r.phase}:${r.t0}:${r.targetId}`;
    if (state._handledRevealKey !== key){
      state._handledRevealKey = key;
      hideCenterReveal();

      const now = Date.now();
      const showAt = (r.t0 || now) + 800;
      const hideAt = showAt + 2000;
      const allAt  = (r.t0 || now) + 5000;

      const targetRole = state.hands?.[r.targetId]?.cards?.[0];
      if (!targetRole) return;

      const delayShow = Math.max(0, showAt - now);
      const delayHide = Math.max(0, hideAt - now);

      setTimeout(() => showCenterRevealSingle(targetRole), delayShow);
      setTimeout(() => hideCenterReveal(), delayHide);

      clearRevealTimers();
      const delayAll = Math.max(0, allAt - Date.now());

      state._allRevealTimerId = setTimeout(() => {
        renderHands();
        renderRevealUI();
      }, delayAll);

      if (state.userId === r.wolfId) {
        state._commitAllTimerId = setTimeout(async () => {
          const cur = state.reveal;
          if (!cur || cur.phase !== 'target') return;
          if (cur.t0 !== r.t0 || cur.targetId !== r.targetId) return;

          await set(ref(db, `rooms/${state.roomCode}/reveal`), {
            ...cur,
            phase: 'all',
            allAt
          });
        }, delayAll);
      }
    }
    return;
  }

  if (r.phase === 'all'){
    clearRevealTimers();
    hideBottomPop();
    hideCenterReveal();
    return;
  }
}

function subscribeReveal(){
  if (!state.roomCode) return;
  const rRef = ref(db, `rooms/${state.roomCode}/reveal`);
  onValue(rRef, snap => {
    state.reveal = snap.val() || null;

    // ★ 全員公開になった直後に一回だけアニメ
    if (state.reveal?.phase === 'all'){
      const key = `${state.reveal.allAt || 0}`;
      if (state._handledAllRevealAnimKey !== key){
        state._handledAllRevealAnimKey = key;
        document.body.classList.add('all-reveal-anim');
        setTimeout(() => document.body.classList.remove('all-reveal-anim'), 650);
      }
    }

    renderHands();
    renderRevealUI();
  });
}

/* ★ 正解処理（通常処理） */
async function handleCorrectConfirmed(){
  if (!state.roomCode) return;
  if (state.userId !== state.masterId) return;

  const mRef = ref(db, `rooms/${state.roomCode}/master`);
  await update(mRef, { boardOpenToAll: true });

  const wolfId = getWolfIdFromHands();
  if (!wolfId) return;

  await set(ref(db, `rooms/${state.roomCode}/reveal`), {
    phase: 'wolf',
    wolfId,
    startedAt: Date.now()
  });
}

/* =========================
   ★ 投票フェーズ（ギリギリ「いいえ」→60秒）
   ========================= */
function clearVoteLocalTick(){
  if (state._voteLocalTick){
    clearInterval(state._voteLocalTick);
    state._voteLocalTick = null;
  }
}

function getSeatedIds(){
  return (latestPlayers || []).map(p => p.id);
}

function voteMyTargetId(){
  const v = state.vote;
  if (!v || !v.votes) return null;
  return v.votes[state.userId] || null;
}
function voteHasMeVoted(){ return !!voteMyTargetId(); }
function voteAllVoted(){
  const v = state.vote;
  if (!v || v.phase !== 'voting') return false;
  const expected = Array.isArray(v.expectedVoters) ? v.expectedVoters : [];
  if (!expected.length) return false;
  const votes = v.votes || {};
  return expected.every(uid => !!votes[uid]);
}
function voteRemainingSec(){
  const v = state.vote;
  if (!v || !v.startedAt || !v.durationSec) return null;
  const end = v.startedAt + v.durationSec * 1000;
  const ms = end - Date.now();
  return Math.max(0, Math.floor(ms / 1000));
}

async function startVotePhaseFromMaster(){
  if (!state.roomCode) return;
  if (state.userId !== state.masterId) return;

  if (state.vote && (state.vote.phase === 'voting' || state.vote.phase === 'result')) return;

  const expectedVoters = getSeatedIds();
  await set(ref(db, `rooms/${state.roomCode}/vote`), {
    phase: 'voting',
    startedAt: Date.now(),
    durationSec: 60,
    expectedVoters,
    votes: {},
    finalizedAt: null,
    winners: [],
    counts: {}
  });
}

async function castVote(targetId){
  if (!state.roomCode) return;
  const v = state.vote;
  if (!v || v.phase !== 'voting') return;
  if (targetId === state.userId) return;

  const voteRef = ref(db, `rooms/${state.roomCode}/vote/votes/${state.userId}`);
  await set(voteRef, targetId);
}

function computeVoteCounts(voteObj){
  const votes = voteObj?.votes || {};
  const counts = {};
  for (const targetId of Object.values(votes)){
    if (!targetId) continue;
    counts[targetId] = (counts[targetId] || 0) + 1;
  }
  return counts;
}
function pickWinners(counts){
  const entries = Object.entries(counts);
  if (!entries.length) return { max: 0, winners: [] };
  let max = 0;
  for (const [,c] of entries) if (c > max) max = c;
  const winners = entries.filter(([,c]) => c === max).map(([id]) => id);
  return { max, winners };
}

async function finalizeVoteIfNeeded(){
  const v = state.vote;
  if (!v || v.phase !== 'voting') return;
  if (!state.roomCode) return;

  const remain = voteRemainingSec();
  const timeUp = (remain === 0);

  if (!voteAllVoted() && !timeUp) return;
  if (!state.isHost) return;

  const curSnap = await get(ref(db, `rooms/${state.roomCode}/vote`));
  const cur = curSnap.val();
  if (!cur || cur.phase !== 'voting') return;

  const counts = computeVoteCounts(cur);
  const { max, winners } = pickWinners(counts);

  await update(ref(db, `rooms/${state.roomCode}/vote`), {
    phase: 'result',
    finalizedAt: Date.now(),
    counts,
    winners,
    maxVotes: max
  });
}

function renderVoteUI(){
  const v = state.vote;

  if (!v || !v.phase) {
    clearVoteLocalTick();

    // ★ voteが消えたら投票ポップも確実に閉じる
    if (state.bottomMode === 'vote'){
      hideBottomPop();
    }

    updateHostSelectingPop();
    syncSeatPopVisibility();
    return;
  }

  if (v.phase === 'voting'){
    state.bottomMode = 'vote';

    const remain = voteRemainingSec();
    const mm = remain !== null ? Math.floor(remain / 60) : 0;
    const ss = remain !== null ? (remain % 60) : 0;
    const t = remain !== null ? `（${mm}:${String(ss).padStart(2,'0')}）` : '';

    showBottomPop(`誰が狼だと思う？ネームタグを選択 ${t}`, false);

    clearVoteLocalTick();
    state._voteLocalTick = setInterval(() => {
      if (!state.vote || state.vote.phase !== 'voting') return;
      const r = voteRemainingSec();
      const mm2 = Math.floor(r / 60);
      const ss2 = r % 60;
      showBottomPop(`誰が狼だと思う？ネームタグを選択 （${mm2}:${String(ss2).padStart(2,'0')}）`, false);

      finalizeVoteIfNeeded();
      renderHands();
    }, 1000);

    finalizeVoteIfNeeded();
    return;
  }

  if (v.phase === 'result'){
    clearVoteLocalTick();
    hideBottomPop();

    const key = `${v.finalizedAt || 0}:${(v.winners||[]).join(',')}:${v.maxVotes||0}`;
    if (state._handledVoteResultKey !== key){
      state._handledVoteResultKey = key;

      // ★ 投票結果を開示したら → 全員の正体カードを開示（reveal all）
      if (state.isHost){
        const nowAllAt = Date.now();
        set(ref(db, `rooms/${state.roomCode}/reveal`), {
          phase: 'all',
          allAt: nowAllAt
        });
      }

      const maxVotes = v.maxVotes || 0;
      const winners = Array.isArray(v.winners) ? v.winners : [];

      if (maxVotes <= 0 || winners.length === 0){
        hideCenterReveal();
        updateHostSelectingPop();
        syncSeatPopVisibility();
        return;
      }

      const roleOf = (uid) => state.hands?.[uid]?.cards?.[0] || null;

      if (winners.length === 1){
        const role = roleOf(winners[0]);
        if (!role) return;
        showCenterRevealSingle(role);
      } else {
        if (maxVotes >= 2){
          const a = roleOf(winners[0]);
          const b = roleOf(winners[1]);
          if (!a || !b) return;
          showCenterRevealDouble(a,b);
        } else {
          const role = roleOf(winners[0]);
          if (!role) return;
          showCenterRevealSingle(role);
        }
      }

      setTimeout(() => hideCenterReveal(), 2600);
    }
    return;
  }
}

function subscribeVote(){
  if (!state.roomCode) return;
  const vRef = ref(db, `rooms/${state.roomCode}/vote`);
  onValue(vRef, snap => {
    state.vote = snap.val() || null;
    renderHands();
    renderVoteUI();
  });
}

/* =========================
   ★ ボタンイベント（仕様反映）
   ========================= */

/* いいえ */
btnGuessNo?.addEventListener('click', async () => {
  if (state.bottomMode === 'correct'){
    const isGiri = bottomPop?.classList.contains('giri');
    hideBottomPop();

    if (isGiri){
      // ギリギリ→いいえ→通常処理（現仕様：全員公開→投票開始）
      if (state.userId === state.masterId){
        await update(ref(db, `rooms/${state.roomCode}/master`), { boardOpenToAll: true });
      }
      await startVotePhaseFromMaster();
    }
    // 正解→いいえ→ポップ閉じるだけ（ここで終了）
    return;
  }

  // wolf等
  hideBottomPop();
  updateHostSelectingPop();
});

/* はい */
btnGuessYes?.addEventListener('click', async () => {
  // 正解ボタン→はい→通常処理
  // ギリギリボタン→はい→通常処理
  if (state.bottomMode === 'correct') {
    hideBottomPop();
    await handleCorrectConfirmed();
    return;
  }

  // 狼フェーズの「この人が占い師？」確認
  const targetId = state._guessPendingTargetId;
  if (!targetId || !state.roomCode) return;

  const wolfId = state.reveal?.wolfId;
  if (state.userId !== wolfId) return;

  hideBottomPop();

  const t0 = Date.now();
  await set(ref(db, `rooms/${state.roomCode}/reveal`), {
    phase: 'target',
    wolfId,
    targetId,
    t0
  });
});

/* ★ 自分の手札：マスターなら mayor.jpg を左に表示 */
function renderMyHand(){
  myHandEl.innerHTML = '';
  const handData = state.hands[state.userId];
  if (!handData || !Array.isArray(handData.cards)) return;

  const isMasterPlayer = (state.userId === state.masterId);

  if (isMasterPlayer){
    const mayorCard = document.createElement('div');
    mayorCard.className = 'my-card role-card';
    mayorCard.style.backgroundImage = 'url("mayor.jpg")';
    mayorCard.title = 'マスター';
    mayorCard.textContent = '';
    myHandEl.appendChild(mayorCard);
  }

  handData.cards.forEach(v => {
    const card = document.createElement('div');
    card.className = 'my-card role-card';

    const img = roleToImage(v);
    card.style.backgroundImage = `url("${img}")`;

    card.title = v;
    card.textContent = '';
    myHandEl.appendChild(card);
  });
}

function renderHands(){
  renderMyHand();
  if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  updateCorrectBtnVisibility();
}

/* 正解!!クリック */
btnCorrect?.addEventListener('click', async () => {
  if (!state.roomCode) return;
  if (state.userId !== state.masterId) return;

  // ★ 0秒封印中は押せない（表示されない想定だが保険）
  if (state.correctBtnLocked) return;

  const wolfId = getWolfIdFromHands();
  if (!wolfId) return;

  state.bottomMode = 'correct';
  showBottomPop('誰かが正解しましたか？', true);
});

/* URL から room= を復元 */
const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

/* =========================
   ★ 席タブ描画（同期ライブ版）
   ========================= */
async function renderSeatTabsLive(roomDataArg, tablesArg){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try{
    seatTabs.innerHTML = '';

    const roomData = roomDataArg ?? (await get(ref(db, `rooms/${state.roomCode}`))).val() ?? {};
    const tables   = tablesArg   ?? (await get(ref(db, `rooms/${state.roomCode}/tables`))).val() ?? {};

    const maxPlayers = roomData.maxPlayers || 8;

    if (!roomData.maxPlayers){
      if (state.isHost){
        seatLabel.textContent = '人数を選択';

        for(let i=2; i<=8; i++){
          const tab = document.createElement('div');
          tab.className = 'tab';
          tab.textContent = i;

          tab.onclick = async () => {
            const roomRef = ref(db, `rooms/${state.roomCode}`);
            await update(roomRef, { maxPlayers: i });

            const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
            await set(tRef, { playerId: state.userId, playerName: state.userName });

            state.seatedTable = 1;
            state.seatPopDismissed = false;
            seatPop.classList.add('hidden');
          };

          seatTabs.appendChild(tab);
        }
      } else {
        seatLabel.textContent = '人数設定中…';
        for(let i=1; i<=8; i++){
          const tab = document.createElement('div');
          tab.className = 'tab disabled';
          tab.textContent = i;
          seatTabs.appendChild(tab);
        }
      }
      return;
    }

    seatLabel.textContent = '席を選択';

    for(let i=1; i<=maxPlayers; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;

        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, { playerId: state.userId, playerName: state.userName });

        state.seatedTable = i;
        state.seatPopDismissed = false;
        seatPop.classList.add('hidden');
      };

      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  state.seatPopDismissed = true;
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

/* 入室 */
btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
    state.hostId = state.userId;
  } else {
    state.isHost = (roomData.hostId === state.userId);
    state.hostId = roomData.hostId;
  }

  updateHostUI();

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');
  document.body.classList.add('in-room');

  latestRoomMeta = (await get(ref(db, `rooms/${state.roomCode}`))).val() || {};
  latestTablesRaw = (await get(ref(db, `rooms/${state.roomCode}/tables`))).val() || {};

  await restoreSeatFromDB();

  if (state.seatedTable === null && !state.seatPopDismissed) {
    if (!isHostSelectingNow() || state.isHost){
      await renderSeatTabsLive(latestRoomMeta, latestTablesRaw);
      seatPop.classList.remove('hidden');
      syncSeatPopVisibility();
    } else {
      seatPop.classList.add('hidden');
    }
  } else {
    seatPop.classList.add('hidden');
  }

  subscribePlayers();
  subscribeRoomMeta();
  subscribeHostState();
  subscribeHands();
  subscribeMaster();
  subscribeReveal();
  subscribeVote();

  // ★ 追加：再スタート合図購読
  subscribeGameKey();

  updateHostSelectingPop();
  syncSeatPopVisibility();
  updateCorrectBtnVisibility();
});

/* リンクコピー */
copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'コピー完了';
    inputCode.value = state.roomCode;

    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='リンクコピー';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});

/* プレイヤー一覧（tables）購読 */
function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    latestTablesRaw = data;

    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || '名無し',
        seatIndex: Number(seatIndex)
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
      state.seatPopDismissed = false;

      if (!isHostSelectingNow() || state.isHost){
        await renderSeatTabsLive(latestRoomMeta, latestTablesRaw);
        seatPop.classList.remove('hidden');
        syncSeatPopVisibility();
      } else {
        seatPop.classList.add('hidden');
      }
    }

    renderPlayerCircle(players);

    if (state.seatedTable === null && !state.seatPopDismissed && !seatPop.classList.contains('hidden')){
      renderSeatTabsLive(latestRoomMeta, latestTablesRaw);
      syncSeatPopVisibility();
    }

    updateHostSelectingPop();
    syncSeatPopVisibility();
  });
}

/* ★ 他プレイヤー視点：マスターに mayor ミニカード表示 + 投票UI */
function renderPlayerCircle(players){
  playerCircle.innerHTML = '';
  if (!players.length) return;

  const v = state.vote;
  const myVoted = voteHasMeVoted();
  const voters = (v && v.votes) ? Object.keys(v.votes).filter(uid => !!v.votes[uid]) : [];
  const counts = (v && v.phase === 'result' && v.counts) ? v.counts : null;

  const n = players.length;
  const radius = 45;
  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;

  const meIndex = players.findIndex(p => p.id === state.userId);

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + radius * Math.cos(angle);
    const y = 50 + radius * Math.sin(angle);

    const isMe = (p.id === state.userId);
    const isMasterPlayer = (p.id === state.masterId);

    const tag = document.createElement('div');
    tag.className =
      'player-tag' +
      (isMe ? ' me' : '') +
      (isMasterPlayer ? ' is-master' : '');

    if (myVoted && !isMe && voters.includes(p.id)){
      tag.classList.add('voted-black');
    }

    tag.textContent = p.name;
    tag.style.left = `${x}%`;
    tag.style.top  = `${y}%`;

    if (v && v.phase === 'voting'){
      const myTarget = voteMyTargetId();
      if (myTarget && myTarget === p.id){
        const mail = document.createElement('div');
        mail.className = 'vote-mail';
        mail.textContent = '✉';
        tag.appendChild(mail);
      }
    }

    if (v && v.phase === 'result' && counts){
      const c = counts[p.id] || 0;
      if (c > 0){
        const vc = document.createElement('div');
        vc.className = 'vote-count';
        vc.textContent = '✉'.repeat(Math.min(8, c));
        tag.appendChild(vc);
      }
    }

    tag.onclick = async () => {
      if (v && v.phase === 'voting'){
        if (p.id === state.userId) return;
        await castVote(p.id);
        return;
      }

      const r = state.reveal;
      if (r && r.phase === 'wolf' && state.userId === r.wolfId){
        if (p.id === state.userId) return;
        state._guessPendingTargetId = p.id;
        state.bottomMode = 'wolf';
        showBottomPop('この人が占い師だと思う？', true);
        return;
      }

      if (r && (r.phase === 'wolf' || r.phase === 'target' || isAllRevealActive())){
        return;
      }

      if (p.id === state.userId) return;
      if (!state.roomCode) return;
      if (state.seatedTable !== null) return;

      if (isHostSelectingNow() && !state.isHost) return;

      pendingSeatIndexToSteal = p.seatIndex;
      pendingSeatPlayerIdToSteal = p.id;

      kickMessage.textContent = `「${p.name}」を追い出して、この席に着席しますか？`;
      kickDialog.classList.remove('hidden');
    };

    const handData = state.hands[p.id];
    if (p.id !== state.userId && handData && Array.isArray(handData.cards) && handData.cards.length){
      const miniHand = document.createElement('div');
      miniHand.className = 'mini-hand';

      const role = handData.cards[0];
      const reveal = shouldRevealRoleForPlayer(p.id);

      if (isMasterPlayer){
        const mayor = document.createElement('div');
        mayor.className = 'mini-card revealed mayor-mini';
        mayor.style.backgroundImage = 'url("mayor.jpg")';
        mayor.style.zIndex = '13';
        mayor.style.transform = 'translate(-50%,0) rotate(0deg)';
        miniHand.appendChild(mayor);
      }

      const card = document.createElement('div');
      card.className = 'mini-card role-mini';

      if (reveal){
        card.classList.add('revealed');
        card.style.backgroundImage = `url("${roleToImage(role)}")`;
      } else {
        card.style.backgroundImage = '';
      }

      card.style.transform = 'translate(-50%,0) rotate(0deg)';
      card.style.zIndex = '12';

      miniHand.appendChild(card);
      tag.appendChild(miniHand);
    }

    playerCircle.appendChild(tag);
  });

  renderRevealUI();
  renderVoteUI();
  updateHostSelectingPop();
  syncSeatPopVisibility();
  updateCorrectBtnVisibility();
}

/* 追い出しダイアログの操作 */
kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});

btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});

btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);

  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};
  await stealSeatState(pendingSeatPlayerIdToSteal, state.userId);

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  await set(tRef, { playerId: state.userId, playerName: state.userName || '名無し' });

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;

  seatPop.classList.add('hidden');
});

/* 初期配役 */
async function dealInitialHands(){
  if (!state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};

  const seated = Object.entries(tables)
    .map(([seatIndex, t]) => (t && t.playerId ? { seatIndex:Number(seatIndex), playerId:t.playerId } : null))
    .filter(Boolean)
    .sort((a,b) => a.seatIndex - b.seatIndex);

  const n = seated.length;
  if (!n) return;

  function buildRoleDeck(count){
    if (count <= 0) return [];
    if (count === 1) return ['村人'];
    if (count === 2) return ['占い師','狼'];
    if (count === 3) return ['占い師','狼','村人'];

    const deck = ['占い師','狼','村人','村人'];
    if (count >= 5) deck.push('千里眼');
    if (count >= 6) deck.push('村人');
    if (count >= 7) deck.push('なにか');
    while (deck.length < count) deck.push('村人');
    return deck;
  }

  function shuffle(arr){
    for (let i = arr.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  const roleDeck = shuffle(buildRoleDeck(n));

  const hands = {};
  seated.forEach((p, i) => {
    hands[p.playerId] = { cards: [ roleDeck[i] ] };
  });

  await set(ref(db, `rooms/${state.roomCode}/hands`), hands);

  clearRevealTimers();
  await set(ref(db, `rooms/${state.roomCode}/reveal`), null);

  await set(ref(db, `rooms/${state.roomCode}/vote`), null);
  clearVoteLocalTick();
  state._handledVoteResultKey = null;
  state._handledAllRevealAnimKey = null;
}

/* マスターとお題をランダム選出 */
async function chooseRandomMasterAndWords(){
  if (!state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};

  const candidates = Object.values(tables)
    .filter(t => t && t.playerId)
    .map(t => t.playerId);

  if (!candidates.length) return;

  const idx = Math.floor(Math.random() * candidates.length);
  const masterId = candidates[idx];

  const allWords = ['りんご','ごりら','らっぱあああああああ','ぱんつ','つり','りす','コーラ','トイレ'];

  const pool = [...allWords];
  const selected = [];
  for (let i = 0; i < 3 && pool.length; i++) {
    const j = Math.floor(Math.random() * pool.length);
    selected.push(pool.splice(j, 1)[0]);
  }

  await set(ref(db, `rooms/${state.roomCode}/master`), {
    id: masterId,
    choices: selected,
    timerPaused: false,
    boardOpenToAll: false
  });
}

/* =========================
   ★ リセット（ホストのみ）
   ========================= */
async function resetGameToHostSelect(){
  if (!state.roomCode) return;
  if (!state.isHost) return;

  const base = `rooms/${state.roomCode}`;
  const updates = {};

  // ★ 全員UI強制リセット用キー（まず更新）
  updates[`${base}/gameKey`] = Date.now();

  updates[`${base}/hands`] = null;
  updates[`${base}/master`] = null;
  updates[`${base}/reveal`] = null;
  updates[`${base}/vote`] = null;

  updates[`${base}/tables`] = null;
  updates[`${base}/maxPlayers`] = null;

  await update(ref(db), updates);

  // ローカル側も即リセット（ホスト画面の体感を良くする）
  resetAllPopsLocal();

  state.seatedTable = null;
  state.seatPopDismissed = false;

  latestRoomMeta = (await get(ref(db, `${base}`))).val() || {};
  latestTablesRaw = (await get(ref(db, `${base}/tables`))).val() || {};
  await renderSeatTabsLive(latestRoomMeta, latestTablesRaw);
  seatPop.classList.remove('hidden');
  syncSeatPopVisibility();

  startPop.classList.add('hidden');
}

/* ホスト設定ボタン */
hostSettingsBtn.addEventListener('click', () => {
  if (!state.isHost) return;
  startPop.classList.toggle('hidden');
});

btnStartPopClose.addEventListener('click', () => {
  startPop.classList.add('hidden');
});

/* ★ リセット */
btnGameReset?.addEventListener('click', async () => {
  await resetGameToHostSelect();
});

/* ゲームスタート */
btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;

  // ★ スタートし直すとき：出ているポップ等を全員で強制リセット（封印解除も含む）
  await update(ref(db, `rooms/${state.roomCode}`), { gameKey: Date.now() });

  await dealInitialHands();
  await chooseRandomMasterAndWords();
  startPop.classList.add('hidden');
});
</script>

</body>
</html>
